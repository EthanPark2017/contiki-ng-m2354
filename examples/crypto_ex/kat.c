#include <stdio.h>
#include <stddef.h>
#include <string.h>

#include "sp_assert.h"
#include "axiocrypto.h"
#include "axiocrypto_util.h"

/**
 * @brief hash 알고리즘을 테스트하는데 사용할 벡터값들의 자료구조
 */
struct hash_test_vector_t {
    ALGORITHM algo;         /**< 알고리즘 종류 */
    uint8_t reserved0;      /**< 자리채우는 용도의 변수 */
    uint16_t msgsz;         /**< 입력 데이터 길이 */
    uint8_t msg[64];        /**< 테스트용 메시지의 값. */
    uint8_t out[32];        /**< 정답지 */
};

const struct hash_test_vector_t hash_kat_vector[] = {

 { .algo = HASH_SM3, .msgsz = 3,
  .msg = {  /* 'abc' */
    0x61,0x62,0x63,},
  .out = {
    0x66,0xC7,0xF0,0xF4,0x62,0xEE,0xED,0xD9,0xD1,0xF2,0xD4,0x6B,0xDC,0x10,0xE4,0xE2,
    0x41,0x67,0xC4,0x87,0x5C,0xF2,0xF7,0xA2,0x29,0x7D,0xA0,0x2B,0x8F,0x4B,0xA8,0xE0,},
 },
 { .algo = HASH_SM3, .msgsz = 46,
  .msg = {  /* 'abcdefghijklmnopqrstuvwxyz' */
    0xF4,0xA3,0x84,0x89,0xE3,0x2B,0x45,0xB6,0xF8,0x76,0xE3,0xAC,0x21,0x68,0xCA,0x39,
    0x23,0x62,0xDC,0x8F,0x23,0x45,0x9C,0x1D,0x11,0x46,0xFC,0x3D,0xBF,0xB7,0xBC,0x9A,
    0x6D,0x65,0x73,0x73,0x61,0x67,0x65,0x20,0x64,0x69,0x67,0x65,0x73,0x74,},
  .out = {
    0xB5,0x24,0xF5,0x52,0xCD,0x82,0xB8,0xB0,0x28,0x47,0x6E,0x00,0x5C,0x37,0x7F,0xB1,
    0x9A,0x87,0xE6,0xFC,0x68,0x2D,0x48,0xBB,0x5D,0x42,0xE3,0xD9,0xB9,0xEF,0xFE,0x76,},
 },
 { .algo = HASH_SHA_256, .msgsz = 14,
  .msg = {  /* 'message digest' */
    0x6D,0x65,0x73,0x73,0x61,0x67,0x65,0x20,0x64,0x69,0x67,0x65,0x73,0x74,},
  .out = {
    0xF7,0x84,0x6F,0x55,0xCF,0x23,0xE1,0x4E,0xEB,0xEA,0xB5,0xB4,0xE1,0x55,0x0C,0xAD,
    0x5B,0x50,0x9E,0x33,0x48,0xFB,0xC4,0xEF,0xA3,0xA1,0x41,0x3D,0x39,0x3C,0xB6,0x50,},
 },
 { .algo = HASH_SHA_256, .msgsz = 26,
  .msg = {  /* 'abcdefghijklmnopqrstuvwxyz' */
    0x61,0x62,0x63,0x64,0x65,0x66,0x67,0x68,0x69,0x6A,0x6B,0x6C,0x6D,0x6E,0x6F,0x70,
    0x71,0x72,0x73,0x74,0x75,0x76,0x77,0x78,0x79,0x7A,},
  .out = {
    0x71,0xC4,0x80,0xDF,0x93,0xD6,0xAE,0x2F,0x1E,0xFA,0xD1,0x44,0x7C,0x66,0xC9,0x52,
    0x5E,0x31,0x62,0x18,0xCF,0x51,0xFC,0x8D,0x9E,0xD8,0x32,0xF2,0xDA,0xF1,0x8B,0x73,},
 },
 { .algo = CRYPTO_ALGO_INITIALIZED, .msgsz =0},
};

static void hash_kat(operation_mode_t opmode)
{
    CRYPTO_STATUS ret = CRYPTO_ERROR;
    ctx_handle_t handle = {0,};
    ALGORITHM algo;
    const struct hash_test_vector_t *vector;
    uint8_t digest[32];
    int i;
    int last;
    uint8_t count = 0;

    last = sizeof(hash_kat_vector) / sizeof(hash_kat_vector[0]);

    handle[0] = 60;
    for (i=0; i < last; ++i) {
        vector = &hash_kat_vector[i];
        if (vector->algo == CRYPTO_ALGO_INITIALIZED && vector->msgsz == 0) {
            break;
        }

        if ((opmode != OP_MODE_APPROVED_OSCCA) &&
            vector->algo == HASH_SM3) {
            continue;
        }

        if (count == 0) {
            algo = vector->algo;
        }
        if (algo != vector->algo) {
            count = 0;
        }

        memset(digest, 0, 32);
        ret = axiocrypto_hash_init(handle, vector->algo);
        sp_assert_equal(ret, CRYPTO_SUCCESS);
        sp_assert_equal(handle[0], 60);

        ret = axiocrypto_hash_update(handle, vector->msg, vector->msgsz);
        sp_assert_equal(ret, CRYPTO_SUCCESS);

        ret = axiocrypto_hash_final(handle, digest, 32);

        sp_assert_equal(ret, CRYPTO_SUCCESS);
        sp_assert_equal(memcmp(vector->out, digest, 32), 0);

        memset(digest, 0, 32);
        ret = axiocrypto_hash(vector->algo, vector->msg, vector->msgsz, digest, 32);
        sp_assert_equal(ret, CRYPTO_SUCCESS);
        sp_assert_equal(memcmp(vector->out, digest, 32), 0);

        printf("KAT %s #%d pass\n", algorithm_string(vector->algo), ++count);
    }
    printf("\n");
}

/**
 * @brief hmac 알고리즘을 테스트하는데 사용할 벡터값들의 자료구조
 */
struct hmac_test_vector_t {
    uint8_t tlen;           /**< MAC의 바이트 단위 길이 */
    uint8_t reserved0;      /**< 자리채우는 용도의 변수 */
    uint16_t reserved1;     /**< 자리채우는 용도의 변수 */
    uint16_t klen;          /**< 비밀키의 길이 */
    uint16_t mlen;          /**< 메시지의 길이 */
    uint8_t key[256];       /**< 테스트용 키 값 */
    uint8_t msg[128];       /**< 테스트용 메시지의 값. */
    uint8_t mac[32];        /**< 정답지 */
};
const struct hmac_test_vector_t hmac_kat[] = {

 { .klen = 16, .mlen = 128, .tlen = 16,
  .key = {
    0xBE,0x48,0x6C,0xE4,0x41,0x8C,0x74,0x94,0x19,0x89,0x31,0x82,0x22,0x38,0x07,0x92,},
  .msg = {
    0x7F,0xBE,0xDB,0x23,0xE1,0x9C,0x79,0xE5,0x05,0x26,0x33,0xEF,0x7F,0x36,0xCB,0x0C,
    0xB7,0x21,0x94,0x56,0x31,0xEA,0xD3,0x07,0x11,0xB6,0x6B,0x8B,0xDE,0x80,0xBA,0xDA,
    0x86,0x0E,0xBE,0x04,0xA2,0x24,0x7C,0x0D,0xFC,0xF7,0xA2,0xFC,0x4E,0xE4,0x6B,0x2F,
    0x4D,0x62,0xC3,0xF1,0xE6,0x36,0xAC,0x4F,0xC8,0xE6,0xE0,0x27,0x22,0x6F,0xB7,0x81,
    0xAE,0x3A,0x4C,0x22,0xEE,0x4D,0xDB,0x5F,0xB6,0xBF,0x6E,0x30,0xEA,0x6E,0xB9,0x85,
    0x89,0xF4,0x42,0xDD,0xEA,0xD6,0xC5,0x14,0x46,0xFF,0xD6,0x7C,0x77,0x6D,0xC8,0x30,
    0xFF,0x2B,0xCE,0xA5,0x4C,0x7F,0x60,0x82,0x3B,0x64,0xE0,0xB2,0xDA,0x3A,0x7E,0xB7,
    0x72,0xBD,0x59,0x41,0xC5,0x34,0xE6,0xFF,0x94,0xEA,0x96,0xB5,0x64,0xE2,0xB3,0x8F,},
  .mac = {
    0x27,0x30,0xFA,0x0A,0xAB,0x91,0x50,0x55,0x1C,0x97,0xCC,0x77,0xD7,0x83,0xF2,0xEE,},
 },
 { .klen = 256, .mlen = 128, .tlen = 32,
  .key = {
    0x5F,0x5B,0x50,0xE7,0x32,0xCC,0x7C,0x27,0x69,0x89,0x65,0x49,0x9E,0x4D,0x28,0x0F,
    0x66,0xF1,0x90,0x21,0x8E,0x97,0x7F,0xED,0xA4,0x29,0x8F,0xB1,0xB9,0x02,0xF8,0xD6,
    0x66,0xEA,0xB5,0x80,0x0D,0x48,0xE2,0x63,0x61,0x93,0x69,0xD8,0x29,0x0A,0xDD,0x30,
    0x41,0xA5,0xA6,0x48,0xE1,0x4B,0x5F,0x5D,0x21,0x45,0x7C,0x22,0xBD,0xF3,0x30,0x10,
    0x16,0xBD,0x8E,0xFE,0x7A,0x4D,0xEE,0xF1,0xA5,0xFB,0x92,0x35,0x88,0x89,0x89,0xAD,
    0x49,0x11,0xD4,0x67,0x8A,0x3B,0xC8,0x73,0xEE,0xB3,0xB3,0xF6,0xD9,0xDB,0xC2,0x7A,
    0x78,0xBD,0x22,0x88,0x02,0x43,0x66,0x79,0x3D,0xAA,0x29,0x89,0x43,0x34,0xF4,0x2D,
    0x86,0x1D,0x62,0xA7,0x12,0xD1,0x81,0xD7,0x12,0x5C,0x7C,0x54,0x96,0x22,0x77,0xBB,
    0x93,0xD0,0xBB,0x47,0x2B,0x92,0x13,0xA2,0x2F,0x87,0x75,0xFB,0xE3,0x72,0xE5,0x59,
    0x01,0xB2,0x97,0x2F,0x00,0x74,0x54,0x30,0x95,0x27,0x1E,0x64,0x7B,0x30,0x17,0x7C,
    0x70,0xDF,0x9F,0x63,0x80,0xA2,0xBD,0x15,0x85,0x79,0xC0,0xB4,0xEF,0xAA,0x26,0xD9,
    0xC1,0xB6,0xBC,0x28,0xDC,0x8B,0x07,0x27,0x80,0xFB,0xE3,0x50,0x10,0x6D,0x6A,0x64,
    0x15,0xD3,0x17,0x03,0x86,0xDC,0x2B,0x7A,0x47,0x6A,0x50,0xDC,0xEF,0x46,0x7D,0x54,
    0xCE,0x13,0x19,0xB9,0x2F,0x80,0x63,0x63,0xDA,0xC2,0x11,0x3D,0xDD,0x42,0x37,0x1C,
    0x8C,0x92,0x6B,0x4F,0xC7,0xA6,0x27,0x78,0x7B,0x41,0x6F,0x9A,0x6B,0xAD,0xB3,0x72,
    0x31,0xAF,0xF6,0x0B,0x7F,0xBA,0x30,0x8D,0xAB,0x63,0xF1,0x55,0x6B,0x15,0x48,0x4B,},
  .msg = {
    0xDD,0x06,0xE3,0x70,0xCA,0x69,0x77,0xB7,0x2B,0xE6,0x63,0x16,0xEC,0x47,0x90,0xDC,
    0xF1,0x74,0x9B,0x45,0x57,0xA1,0x36,0x4C,0xFC,0xC6,0xCB,0xC0,0x41,0x4F,0x63,0x9A,
    0x0E,0x15,0xC7,0x8E,0x17,0x8E,0xE4,0xE0,0x5E,0x40,0x74,0x79,0xF9,0x7C,0xDB,0x3A,
    0x16,0x48,0x4F,0x90,0x3C,0x9D,0x3C,0x49,0xD4,0xD3,0xE7,0xA6,0xE7,0x59,0x51,0xB1,
    0x29,0xA9,0x5E,0xD0,0x37,0x7B,0x36,0x9B,0x1D,0x39,0xEC,0xEB,0x1B,0xB4,0x5E,0x33,
    0xA9,0x15,0x5C,0x14,0xB8,0x16,0x0C,0x2B,0x3B,0x72,0x8C,0x2E,0xE6,0x99,0xDA,0x37,
    0x35,0xA9,0xF1,0x5F,0xB1,0x9A,0x35,0x8F,0x6F,0xB8,0x11,0x93,0xD9,0x57,0xDF,0x70,
    0xB0,0xC2,0x08,0xF8,0x52,0x74,0x6C,0x9B,0x39,0x8B,0x04,0x80,0xC5,0x79,0xC5,0xD5,},
  .mac = {
    0x58,0x5F,0x5A,0x42,0xF9,0x3D,0x62,0x37,0x80,0x02,0xE0,0x15,0xDB,0x06,0x10,0x06,
    0x9A,0x26,0x7A,0x26,0x7F,0x72,0x12,0x78,0x1F,0x31,0xFC,0x17,0xDA,0xAF,0x7C,0x35,},
 },

{ .klen =0, .tlen =0},
};


void hmac_sha256_kat(void)
{
    CRYPTO_STATUS ret = CRYPTO_SUCCESS;
    const struct hmac_test_vector_t *vector;
    uint8_t digest[32];
    ctx_handle_t handle = {0,};
    int i;

    handle[0] = 50;
    for (i=0; ; ++i) {
        vector = &hmac_kat[i];
        if (vector->klen == 0 && vector->tlen == 0) {
            break;
        }

        ret = axiocrypto_allocate_slot(handle, HMAC_SHA_256, 0);
        sp_assert_equal(ret, 0);

        memset(digest, 0, 32);
        ret = axiocrypto_hmac_putkey(handle, HMAC_SHA_256, vector->key, vector->klen, axiocrypto_crc(vector->key, vector->klen));
        sp_assert_equal(ret, 0);
        sp_assert_equal(handle[0], 50);

        ret = axiocrypto_hmac_init(handle);
        sp_assert_equal(ret, 0);

        ret = axiocrypto_hmac_update(handle, vector->msg, vector->mlen);
        sp_assert_equal(ret, 0);

        ret = axiocrypto_hmac_final(handle, digest, 32);
        sp_assert_equal(ret, 0);
        sp_assert_equal(memcmp(vector->mac, digest, vector->tlen), 0);

        memset(digest, 0, 32);
        ret = axiocrypto_hmac( HMAC_SHA_256,
              vector->key, vector->klen, vector->msg, vector->mlen,
              digest, 32);
        sp_assert_equal(ret, 0);
        sp_assert_equal(memcmp(vector->mac, digest, vector->tlen), 0);

        ret = axiocrypto_free_slot(handle, HMAC_SHA_256);
        sp_assert_equal(ret, 0);

        printf("KAT %s #%d pass\n", algorithm_string(HMAC_SHA_256), i);
    }
    printf("\n");
}

/**
 * @brief ECB 알고리즘을 테스트하는데 사용할 벡터값들의 자료구조
 */
struct ecb_test_vector_t {
    ALGORITHM algo;         /**< 알고리즘 종류 */
    uint8_t reserved0;      /**< 자리채우는 용도의 변수 */
    uint16_t keysz;         /**< 키 길이 */
    uint8_t key[32];        /**< 키 데이터 */
    uint8_t pt[16];        /**< 평문 데이터 */
    uint8_t ct[16];        /**< 암호 데이터 */
};

struct ecb_test_vector_t ecb_kat_vector[] = {

 { .algo = SYM_AES, .keysz = 128,
  .key = {
    0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .pt = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .ct = {
    0x0e,0xdd,0x33,0xd3,0xc6,0x21,0xe5,0x46,0x45,0x5b,0xd8,0xba,0x14,0x18,0xbe,0xc8,},
 },
 { .algo = SYM_AES, .keysz = 192,
  .key = {
    0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .pt = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .ct = {
    0xDE,0x88,0x5D,0xC8,0x7F,0x5A,0x92,0x59,0x40,0x82,0xD0,0x2C,0xC1,0xE1,0xB4,0x2C,},
 },
 { .algo = SYM_AES, .keysz = 256,
  .key = {
    0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .pt = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .ct = {
    0xE3,0x5A,0x6D,0xCB,0x19,0xB2,0x01,0xA0,0x1E,0xBC,0xFA,0x8A,0xA2,0x2B,0x57,0x59,},
 },
 /* SM4 test vectors from IETF draft-ribose-cfrg-sm4 */
 { .algo = SYM_SM4, .keysz = 128,
  .key = {
    0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10,},
  .pt = {
    0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10,},
  .ct = {
    0x68,0x1E,0xDF,0x34,0xD2,0x06,0x96,0x5E,0x86,0xB3,0xE9,0x4F,0x53,0x6E,0x42,0x46,},
 },
 { .algo = CRYPTO_ALGO_INITIALIZED, .keysz = 0},
};

// ECB is only allowed with AES
void ecb_kat(operation_mode_t opmode)
{
    CRYPTO_STATUS ret = CRYPTO_ERROR;
    ctx_handle_t handle = {0,};
    struct ecb_test_vector_t *vector;
    uint8_t buf[16];
    int rdonly = 0;
    int i;
    int last;
    uint32_t keysz = 0;
    uint32_t sz = 0;

    handle[0] = 25;
    last = sizeof(ecb_kat_vector) / sizeof(ecb_kat_vector[0]);

    for (i=0; i < last; ++i) {
        vector = &ecb_kat_vector[i];
        if (vector->algo == CRYPTO_ALGO_INITIALIZED && vector->keysz == 0) {
            break;
        }

        if (((opmode == OP_MODE_APPROVED_KCMVP) || (opmode == OP_MODE_APPROVED_OSCCA)) &&
             (vector->algo & SYM_MASK) == SYM_AES) {
            continue;
        } else if ((opmode != OP_MODE_APPROVED_OSCCA) &&
             (vector->algo & SYM_MASK) == SYM_SM4) {
            continue;
        }

        memset(buf, 0, sizeof(buf));
        ret = axiocrypto_allocate_slot(handle, vector->algo, 0);
        sp_assert_equal(ret, CRYPTO_SUCCESS);

        keysz = vector->keysz >> 3;
        ret = axiocrypto_sym_putkey(handle, vector->key, keysz, axiocrypto_crc(vector->key, keysz), rdonly);
        sp_assert_equal(ret, CRYPTO_SUCCESS);

        sz = 16;
        ret = axiocrypto_sym_enc_ECB(handle, vector->algo, vector->pt, sizeof(vector->pt), buf, &sz);
        sp_assert_equal(ret, CRYPTO_SUCCESS);
        sp_assert_equal(sz, 16);
        sp_assert_equal(memcmp(vector->ct, buf, 16), 0);
        printf("KAT %s-ECB-%d ENC pass\n", algorithm_string(vector->algo), vector->keysz);

        memset(buf, 0, sizeof(buf));
        sz = 16;
        ret = axiocrypto_sym_dec_ECB(handle, vector->algo, vector->ct, sizeof(vector->ct), buf, &sz);
        sp_assert_equal(ret, CRYPTO_SUCCESS);
        sp_assert_equal(sz, 16);
        sp_assert_equal(memcmp(vector->pt, buf, 16), 0);
        printf("KAT %s-ECB-%d DEC pass\n", algorithm_string(vector->algo), vector->keysz);
    }
    printf("\n");
}

/**
 * @brief CBC 알고리즘을 테스트하는데 사용할 벡터값들의 자료구조
 */
struct cbc_test_vector_t {
    ALGORITHM algo;        /**< 알고리즘 종류 */
    uint8_t sz;            /**< 입/출력 길이 */
    uint16_t keysz;        /**< 키 길이 */
    uint8_t key[32];       /**< 키 데이터 */
    uint8_t iv[16];        /**< 평문 데이터 */
    uint8_t pt[32];        /**< 평문 데이터 */
    uint8_t ct[32];        /**< 암호 데이터 */
};

struct cbc_test_vector_t cbc_kat_vector[] = {

 { .algo = SYM_AES, .sz = 16, .keysz = 128,
  .key = {
    0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .iv = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .pt = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .ct = {
    0x0E,0xDD,0x33,0xD3,0xC6,0x21,0xE5,0x46,0x45,0x5B,0xD8,0xBA,0x14,0x18,0xBE,0xC8,},
 },
 { .algo = SYM_AES, .sz = 16, .keysz = 192,
  .key = {
    0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .iv = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .pt = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .ct = {
    0xDE,0x88,0x5D,0xC8,0x7F,0x5A,0x92,0x59,0x40,0x82,0xD0,0x2C,0xC1,0xE1,0xB4,0x2C,},
 },
 { .algo = SYM_AES, .sz = 16, .keysz = 256,
  .key = {
    0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .iv = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .pt = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .ct = {
    0xE3,0x5A,0x6d,0xCB,0x19,0xB2,0x01,0xA0,0x1E,0xBC,0xFA,0x8A,0xA2,0x2B,0x57,0x59,},
 },
 { .algo = SYM_ARIA, .sz = 16, .keysz = 128,
  .key = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .iv = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .pt = {
    0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .ct = {
    0x92,0xE5,0x1E,0x73,0x7D,0xAB,0xB6,0xBF,0xD0,0xEA,0xBC,0x8D,0x32,0x22,0x4F,0x77,},
 },
 { .algo = SYM_ARIA, .sz = 16, .keysz = 192,
  .key = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .iv = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .pt = {
    0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .ct = {
    0xAE,0x56,0xBF,0x59,0x87,0x4E,0xD4,0xDB,0xD7,0xB9,0x05,0x87,0x88,0x94,0xAD,0xEE,},
 },
 { .algo = SYM_ARIA, .sz = 16, .keysz = 256,
  .key = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .iv = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .pt = {
    0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .ct = {
    0x20,0x9A,0xCF,0x63,0xCE,0x6D,0xFB,0x56,0xB1,0xF9,0x82,0x1D,0xDB,0xFE,0x86,0xE3,},
 },
 { .algo = SYM_LEA, .sz = 16, .keysz = 128,
  .key = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .iv = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .pt = {
    0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .ct = {
    0xCE,0x8D,0xCF,0x04,0xDD,0x60,0x98,0x2B,0x1D,0x8F,0x50,0x35,0xFD,0x53,0x4D,0xE2,},
 },
 { .algo = SYM_LEA, .sz = 16, .keysz = 192,
  .key = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .iv = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .pt = {
    0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .ct = {
    0xF0,0xDE,0x5F,0x83,0x74,0x90,0x5B,0xB3,0x1E,0x01,0x10,0xAD,0xF1,0x09,0xED,0xD2,},
 },
 { .algo = SYM_LEA, .sz = 16, .keysz = 256,
  .key = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .iv = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .pt = {
    0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .ct = {
    0xBA,0x91,0xD6,0x22,0xBA,0xF6,0x83,0xD7,0xBF,0xCF,0x17,0x85,0xFB,0xE3,0x2A,0x44,},
 },
 { .algo = SYM_SM4, .sz = 32, .keysz = 128,
  .key = {
    0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10,},
  .iv = {
    0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10,},
  .pt = {
    0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10,
    0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10,},
  .ct = {
   0x26,0x77,0xF4,0x6B,0x09,0xC1,0x22,0xCC,0x97,0x55,0x33,0x10,0x5B,0xD4,0xA2,0x2A,
   0xF6,0x12,0x5F,0x72,0x75,0xCE,0x55,0x2C,0x3A,0x2B,0xBC,0xF5,0x33,0xDE,0x8A,0x3B,},
 },
 { .algo = CRYPTO_ALGO_INITIALIZED, .sz = 0, .keysz = 0},
};

void cbc_kat(operation_mode_t opmode)
{
    CRYPTO_STATUS ret = CRYPTO_ERROR;
    struct cbc_test_vector_t *vector;
    ctx_handle_t handle = {0,};
    int rdonly = 0;
    uint8_t buf[32];
    uint32_t sz;
    int i;
    int last;
    int keybyte;

    handle[0] = 28;
    last = sizeof(cbc_kat_vector) / sizeof(cbc_kat_vector[0]);

    for (i=0; i < last; ++i) {
        vector = &cbc_kat_vector[i];
        if (vector->algo == CRYPTO_ALGO_INITIALIZED && vector->keysz == 0) {
            break;
        }

        if (((opmode == OP_MODE_APPROVED_KCMVP) || (opmode == OP_MODE_APPROVED_OSCCA)) &&
            (vector->algo & SYM_MASK) == SYM_AES) {
            continue;
        } else if (((opmode == OP_MODE_APPROVED_FIPS1402) || (opmode == OP_MODE_APPROVED_OSCCA)) &&
            ((vector->algo & SYM_MASK) == SYM_ARIA || (vector->algo & SYM_MASK) == SYM_LEA)) {
            continue;
        } else if ((opmode != OP_MODE_APPROVED_OSCCA) &&
            (vector->algo & SYM_MASK) == SYM_SM4) {
            continue;
        }

        ret = axiocrypto_allocate_slot(handle, vector->algo, 0);
        sp_assert_equal(ret, CRYPTO_SUCCESS);

        /* bit to byte */
        keybyte = vector->keysz >> 3;
        ret = axiocrypto_sym_putkey(handle, vector->key, keybyte, axiocrypto_crc(vector->key, keybyte), rdonly);
        sp_assert_equal(ret, CRYPTO_SUCCESS);

        ret = axiocrypto_sym_enc_init(handle, vector->algo, SYM_MODE_CBC, vector->iv, sizeof(vector->iv));
        sp_assert_equal(ret, CRYPTO_SUCCESS);

        sz = vector->sz;
        ret = axiocrypto_sym_enc_update(handle, vector->pt, vector->sz, buf, &sz);
        sp_assert_equal(ret, CRYPTO_SUCCESS);
        sp_assert_equal(sz, vector->sz);

        ret = axiocrypto_sym_enc_final(handle, NULL, 0);
        sp_assert_equal(ret, CRYPTO_SUCCESS);
        sp_assert_equal(memcmp(vector->ct, buf, vector->sz), 0);

        printf("KAT %s-CBC-%d ENC pass\n", algorithm_string(vector->algo), vector->keysz);

        memset(buf, 0, sizeof(buf));
        ret = axiocrypto_sym_dec_init(handle, vector->algo, SYM_MODE_CBC, vector->iv, sizeof(vector->iv));
        sp_assert_equal(ret, CRYPTO_SUCCESS);

        sz = vector->sz;
        ret = axiocrypto_sym_dec_update(handle, vector->ct, vector->sz, buf, &sz);
        sp_assert_equal(ret, CRYPTO_SUCCESS);
        sp_assert_equal(sz, vector->sz);

        ret = axiocrypto_sym_dec_final(handle, NULL, 0);
        sp_assert_equal(ret, CRYPTO_SUCCESS);
        sp_assert_equal(memcmp(vector->pt, buf, vector->sz), 0);

        ret = axiocrypto_free_slot(handle, vector->algo);
        sp_assert_equal(ret, CRYPTO_SUCCESS);

        printf("KAT %s-CBC-%d DEC pass\n", algorithm_string(vector->algo), vector->keysz);
    }
    printf("\n");
}

/**
 * @brief CTR 알고리즘을 테스트하는데 사용할 벡터값들의 자료구조
 * @desc  AES Counter test vectors from RFC3686
 */
struct ctr_test_vector_t {
    ALGORITHM algo;        /**< 알고리즘 종류 */
    uint8_t sz;            /**< 입/출력 길이 */
    uint16_t keysz;        /**< 키 길이 */
    uint8_t key[32];       /**< 키 데이터 */
    uint8_t iv[16];        /**< 평문 데이터 */
    uint8_t pt[64];        /**< 평문 데이터 */
    uint8_t ct[64];        /**< 암호 데이터 */
};

struct ctr_test_vector_t ctr_kat_vector[] = {

 { .algo = SYM_AES, .sz = 16, .keysz = 128,
  .key = {
    0xAE,0x68,0x52,0xF8,0x12,0x10,0x67,0xCC,0x4B,0xF7,0xA5,0x76,0x55,0x77,0xF3,0x9E,},
  .iv = {
    0x00,0x00,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,},
  .pt = {
    0x53,0x69,0x6E,0x67,0x6C,0x65,0x20,0x62,0x6C,0x6F,0x63,0x6B,0x20,0x6D,0x73,0x67,},
  .ct = {
    0xE4,0x09,0x5D,0x4F,0xB7,0xA7,0xB3,0x79,0x2D,0x61,0x75,0xA3,0x26,0x13,0x11,0xB8,},
 },
 { .algo = SYM_AES, .sz = 16, .keysz = 192,
  .key = {
    0x16,0xAF,0x5B,0x14,0x5F,0xC9,0xF5,0x79,0xC1,0x75,0xF9,0x3E,0x3B,0xFB,0x0E,0xED,
    0x86,0x3D,0x06,0xCC,0xFD,0xB7,0x85,0x15,},
  .iv = {
    0x00,0x00,0x00,0x48,0x36,0x73,0x3C,0x14,0x7D,0x6D,0x93,0xCB,0x00,0x00,0x00,0x01,},
  .pt = {
    0x53,0x69,0x6E,0x67,0x6C,0x65,0x20,0x62,0x6C,0x6F,0x63,0x6B,0x20,0x6D,0x73,0x67,},
  .ct = {
    0x4B,0x55,0x38,0x4F,0xE2,0x59,0xC9,0xC8,0x4E,0x79,0x35,0xA0,0x03,0xCB,0xE9,0x28,},
 },
 { .algo = SYM_AES, .sz = 16, .keysz = 256,
  .key = {
    0x77,0x6B,0xEF,0xF2,0x85,0x1D,0xB0,0x6F,0x4C,0x8A,0x05,0x42,0xC8,0x69,0x6F,0x6C,
    0x6A,0x81,0xAF,0x1E,0xEC,0x96,0xB4,0xD3,0x7F,0xC1,0xD6,0x89,0xE6,0xC1,0xC1,0x04,},
  .iv = {
    0x00,0x00,0x00,0x60,0xDB,0x56,0x72,0xC9,0x7A,0xA8,0xF0,0xB2,0x00,0x00,0x00,0x01,},
  .pt = {
    0x53,0x69,0x6E,0x67,0x6C,0x65,0x20,0x62,0x6C,0x6F,0x63,0x6B,0x20,0x6D,0x73,0x67,},
  .ct = {
    0x14,0x5A,0xD0,0x1D,0xBF,0x82,0x4E,0xC7,0x56,0x08,0x63,0xDC,0x71,0xE3,0xE0,0xC0,},
 },
 { .algo = SYM_ARIA, .sz = 16, .keysz = 128,
  .key = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .iv = {
    0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .pt = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .ct = {
    0x92,0xE5,0x1E,0x73,0x7D,0xAB,0xB6,0xBF,0xD0,0xEA,0xBC,0x8D,0x32,0x22,0x4F,0x77,},
 },
 { .algo = SYM_ARIA, .sz = 16, .keysz = 192,
  .key = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .iv = {
    0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .pt = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .ct = {
    0xAE,0x56,0xBF,0x59,0x87,0x4E,0xD4,0xDB,0xD7,0xB9,0x05,0x87,0x88,0x94,0xAD,0xEE,},
 },
 { .algo = SYM_ARIA, .sz = 16, .keysz = 256,
  .key = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .iv = {
    0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .pt = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .ct = {
    0x20,0x9A,0xCF,0x63,0xCE,0x6D,0xFB,0x56,0xB1,0xF9,0x82,0x1D,0xDB,0xFE,0x86,0xE3,},
 },
 { .algo = SYM_LEA, .sz = 16, .keysz = 128,
  .key = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .iv = {
    0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .pt = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .ct = {
    0xCE,0x8D,0xCF,0x04,0xDD,0x60,0x98,0x2B,0x1D,0x8F,0x50,0x35,0xFD,0x53,0x4D,0xE2,},
 },
 { .algo = SYM_LEA, .sz = 16, .keysz = 192,
  .key = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .iv = {
    0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .pt = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .ct = {
    0xF0,0xDE,0x5F,0x83,0x74,0x90,0x5B,0xB3,0x1E,0x01,0x10,0xAD,0xF1,0x09,0xED,0xD2,},
 },
 { .algo = SYM_LEA, .sz = 16, .keysz = 256,
  .key = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .iv = {
    0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .pt = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,},
  .ct = {
    0xBA,0x91,0xD6,0x22,0xBA,0xF6,0x83,0xD7,0xBF,0xCF,0x17,0x85,0xFB,0xE3,0x2A,0x44,},
 },
 { .algo = SYM_SM4, .sz = 64, .keysz = 128,
  .key = {
    0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10,},
  .iv = {
    0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10,},
  .pt = {
    0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
    0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,
    0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,},
  .ct = {
    0xC2,0xB4,0x75,0x9E,0x78,0xAC,0x3C,0xF4,0x3D,0x08,0x52,0xF4,0xE8,0xD5,0xF9,0xFD,
    0x72,0x56,0xE8,0xA5,0xFC,0xB6,0x5A,0x35,0x0E,0xE0,0x06,0x30,0x91,0x2E,0x44,0x49,
    0x2A,0x0B,0x17,0xE1,0xB8,0x5B,0x06,0x0D,0x0F,0xBA,0x61,0x2D,0x8A,0x95,0x83,0x16,
    0x38,0xB3,0x61,0xFD,0x5F,0xFA,0xCD,0x94,0x2F,0x08,0x14,0x85,0xA8,0x3C,0xA3,0x5D,},
 },
 { .algo = CRYPTO_ALGO_INITIALIZED, .sz = 0, .keysz = 0},
};

void ctr_kat(operation_mode_t opmode)
{
    CRYPTO_STATUS ret = CRYPTO_ERROR;
    struct ctr_test_vector_t *vector;
    ctx_handle_t handle = {0,};
    int rdonly = 0;
    uint8_t buf[64];
    uint32_t sz;
    int i;
    int last;
    int keybyte;

    handle[0] = 30;
    last = sizeof(ctr_kat_vector) / sizeof(ctr_kat_vector[0]);

    for (i=0; i < last; ++i) {
        vector = &ctr_kat_vector[i];
        if (vector->algo == CRYPTO_ALGO_INITIALIZED && vector->keysz == 0) {
            break;
        }

        if (((opmode == OP_MODE_APPROVED_KCMVP) || (opmode == OP_MODE_APPROVED_OSCCA)) &&
            (vector->algo & SYM_MASK) == SYM_AES) {
            continue;
        } else if (((opmode == OP_MODE_APPROVED_FIPS1402) || (opmode == OP_MODE_APPROVED_OSCCA)) &&
            ((vector->algo & SYM_MASK) == SYM_ARIA || (vector->algo & SYM_MASK) == SYM_LEA)) {
            continue;
        } else if ((opmode != OP_MODE_APPROVED_OSCCA) &&
            (vector->algo & SYM_MASK) == SYM_SM4) {
            continue;
        }

        memset(buf, 0, sizeof(buf));
        ret = axiocrypto_allocate_slot(handle, vector->algo, 0);
        sp_assert_equal(ret, CRYPTO_SUCCESS);

        keybyte = vector->keysz >> 3;
        ret = axiocrypto_sym_putkey(handle, vector->key, keybyte, axiocrypto_crc(vector->key, keybyte), rdonly);
        sp_assert_equal(ret, CRYPTO_SUCCESS);

        ret = axiocrypto_sym_enc_init(handle, vector->algo, SYM_MODE_CTR, vector->iv, sizeof(vector->iv));
        sp_assert_equal(ret, CRYPTO_SUCCESS);

        sz = vector->sz;
        ret = axiocrypto_sym_enc_update(handle, vector->pt, vector->sz, buf, &sz);
        sp_assert_equal(ret, CRYPTO_SUCCESS);
        sp_assert_equal(sz, vector->sz);

        ret = axiocrypto_sym_enc_final(handle, NULL, 0);
        sp_assert_equal(ret, CRYPTO_SUCCESS);
        sp_assert_equal(memcmp(vector->ct, buf, vector->sz), 0);

        printf("KAT %s-CTR-%d ENC pass\n", algorithm_string(vector->algo), vector->keysz);

        memset(buf, 0, sizeof(buf));

        ret = axiocrypto_sym_dec_init(handle, vector->algo, SYM_MODE_CTR, vector->iv, sizeof(vector->iv));
        sp_assert_equal(ret, CRYPTO_SUCCESS);

        sz = vector->sz;
        ret = axiocrypto_sym_dec_update(handle, vector->ct, 16, buf, &sz);
        sp_assert_equal(ret, CRYPTO_SUCCESS);
        sp_assert_equal(sz, vector->sz);

        ret = axiocrypto_sym_dec_final(handle, NULL, 0);
        sp_assert_equal(ret, CRYPTO_SUCCESS);
        sp_assert_equal(memcmp(vector->pt, buf, 16), 0);

        ret = axiocrypto_free_slot(handle, vector->algo);
        sp_assert_equal(ret, CRYPTO_SUCCESS);

        printf("KAT %s-CTR-%d DEC pass\n", algorithm_string(vector->algo), vector->keysz);
    }
    printf("\n");
}

/**
 * @brief CBC 알고리즘을 테스트하는데 사용할 벡터값들의 자료구조
 */
struct gcm_test_vector_t {
    ALGORITHM algo;        /**< 알고리즘 종류 */
    uint8_t ivsz;          /**< IV 길이 */
    uint16_t keysz;        /**< 키 길이 */
    uint16_t sz;           /**< 입/출력 길이 */
    uint16_t aadsz;        /**< 인증 데이터 길이 */
    uint8_t key[32];       /**< 키 데이터 */
    uint8_t iv[16];        /**< 평문 데이터 */
    uint8_t pt[128];       /**< 평문 데이터 */
    uint8_t ct[128];       /**< 암호 데이터 */
    uint8_t aad[128];      /**< 인증 데이터 */
    uint8_t tag[16];       /**< TAG 데이터 */
};

struct gcm_test_vector_t gcm_kat_vector[] = {

 { .algo = SYM_AES, .ivsz = 12, .keysz = 128, .sz = 60, .aadsz = 20,
  .key = {
    0xFE,0xFF,0xE9,0x92,0x86,0x65,0x73,0x1C,0x6D,0x6A,0x8F,0x94,0x67,0x30,0x83,0x08,},
  .iv = {
    0xCA,0xFE,0xBA,0xBE,0xFA,0xCE,0xDB,0xAD,0xDE,0xCA,0xF8,0x88,},
  .pt = {
    0xD9,0x31,0x32,0x25,0xF8,0x84,0x06,0xE5,0xA5,0x59,0x09,0xC5,0xAF,0xF5,0x26,0x9A,
    0x86,0xA7,0xA9,0x53,0x15,0x34,0xF7,0xDA,0x2E,0x4C,0x30,0x3D,0x8A,0x31,0x8A,0x72,
    0x1C,0x3C,0x0C,0x95,0x95,0x68,0x09,0x53,0x2F,0xCF,0x0E,0x24,0x49,0xA6,0xB5,0x25,
    0xB1,0x6A,0xED,0xF5,0xAA,0x0D,0xE6,0x57,0xBA,0x63,0x7B,0x39,},
  .ct = {
    0x42,0x83,0x1E,0xC2,0x21,0x77,0x74,0x24,0x4B,0x72,0x21,0xB7,0x84,0xD0,0xD4,0x9C,
    0xE3,0xAA,0x21,0x2F,0x2C,0x02,0xA4,0xE0,0x35,0xC1,0x7E,0x23,0x29,0xAC,0xA1,0x2E,
    0x21,0xD5,0x14,0xB2,0x54,0x66,0x93,0x1C,0x7D,0x8F,0x6A,0x5A,0xAC,0x84,0xAA,0x05,
    0x1B,0xA3,0x0B,0x39,0x6A,0x0A,0xAC,0x97,0x3D,0x58,0xE0,0x91,},
  .aad = {
    0xFE,0xED,0xFA,0xCE,0xDE,0xAD,0xBE,0xEF,0xFE,0xED,0xFA,0xCE,0xDE,0xAD,0xBE,0xEF,
    0xAB,0xAD,0xDA,0xD2,},
  .tag = {
    0x5B,0xC9,0x4F,0xBC,0x32,0x21,0xA5,0xDB,0x94,0xFA,0xE9,0x5A,0xE7,0x12,0x1A,0x47,},
 },
 { .algo = SYM_AES, .ivsz = 12, .keysz = 192, .sz = 60, .aadsz = 20,
  .key = {
    0xFE,0xFF,0xE9,0x92,0x86,0x65,0x73,0x1C,0x6D,0x6A,0x8F,0x94,0x67,0x30,0x83,0x08,
    0xFE,0xFF,0xE9,0x92,0x86,0x65,0x73,0x1C,},
  .iv = {
    0xCA,0xFE,0xBA,0xBE,0xFA,0xCE,0xDB,0xAD,0xDE,0xCA,0xF8,0x88,},
  .pt = {
    0xD9,0x31,0x32,0x25,0xF8,0x84,0x06,0xE5,0xA5,0x59,0x09,0xC5,0xAF,0xF5,0x26,0x9A,
    0x86,0xA7,0xA9,0x53,0x15,0x34,0xF7,0xDA,0x2E,0x4C,0x30,0x3D,0x8A,0x31,0x8A,0x72,
    0x1C,0x3C,0x0C,0x95,0x95,0x68,0x09,0x53,0x2F,0xCF,0x0E,0x24,0x49,0xA6,0xB5,0x25,
    0xB1,0x6A,0xED,0xF5,0xAA,0x0D,0xE6,0x57,0xBA,0x63,0x7B,0x39,},
  .ct = {
    0x39,0x80,0xCA,0x0B,0x3C,0x00,0xE8,0x41,0xEB,0x06,0xFA,0xC4,0x87,0x2A,0x27,0x57,
    0x85,0x9E,0x1C,0xEA,0xA6,0xEF,0xD9,0x84,0x62,0x85,0x93,0xB4,0x0C,0xA1,0xE1,0x9C,
    0x7D,0x77,0x3D,0x00,0xC1,0x44,0xC5,0x25,0xAC,0x61,0x9D,0x18,0xC8,0x4A,0x3F,0x47,
    0x18,0xE2,0x44,0x8B,0x2F,0xE3,0x24,0xD9,0xCC,0xDA,0x27,0x10,},
  .aad = {
    0xFE,0xED,0xFA,0xCE,0xDE,0xAD,0xBE,0xEF,0xFE,0xED,0xFA,0xCE,0xDE,0xAD,0xBE,0xEF,
    0xAB,0xAD,0xDA,0xD2,},
  .tag = {
    0x25,0x19,0x49,0x8E,0x80,0xF1,0x47,0x8F,0x37,0xBA,0x55,0xBD,0x6D,0x27,0x61,0x8C,},
 },
 { .algo = SYM_AES, .ivsz = 12, .keysz = 256, .sz = 60, .aadsz = 20,
  .key = {
    0xFE,0xFF,0xE9,0x92,0x86,0x65,0x73,0x1C,0x6D,0x6A,0x8F,0x94,0x67,0x30,0x83,0x08,
    0xFE,0xFF,0xE9,0x92,0x86,0x65,0x73,0x1C,0x6D,0x6A,0x8F,0x94,0x67,0x30,0x83,0x08,},
  .iv = {
    0xCA,0xFE,0xBA,0xBE,0xFA,0xCE,0xDB,0xAD,0xDE,0xCA,0xF8,0x88,},
  .pt = {
    0xD9,0x31,0x32,0x25,0xF8,0x84,0x06,0xE5,0xA5,0x59,0x09,0xC5,0xAF,0xF5,0x26,0x9A,
    0x86,0xA7,0xA9,0x53,0x15,0x34,0xF7,0xDA,0x2E,0x4C,0x30,0x3D,0x8A,0x31,0x8A,0x72,
    0x1C,0x3C,0x0C,0x95,0x95,0x68,0x09,0x53,0x2F,0xCF,0x0E,0x24,0x49,0xA6,0xB5,0x25,
    0xB1,0x6A,0xED,0xF5,0xAA,0x0D,0xE6,0x57,0xBA,0x63,0x7B,0x39,},
  .ct = {
    0x52,0x2D,0xC1,0xF0,0x99,0x56,0x7D,0x07,0xF4,0x7F,0x37,0xA3,0x2A,0x84,0x42,0x7D,
    0x64,0x3A,0x8C,0xDC,0xBF,0xE5,0xC0,0xC9,0x75,0x98,0xA2,0xBD,0x25,0x55,0xD1,0xAA,
    0x8C,0xB0,0x8E,0x48,0x59,0x0D,0xBB,0x3D,0xA7,0xB0,0x8B,0x10,0x56,0x82,0x88,0x38,
    0xC5,0xF6,0x1E,0x63,0x93,0xBA,0x7A,0x0A,0xBC,0xC9,0xF6,0x62,},
  .aad = {
    0xFE,0xED,0xFA,0xCE,0xDE,0xAD,0xBE,0xEF,0xFE,0xED,0xFA,0xCE,0xDE,0xAD,0xBE,0xEF,
    0xAB,0xAD,0xDA,0xD2,},
  .tag = {
    0x76,0xFC,0x6E,0xCE,0x0F,0x4E,0x17,0x68,0xCD,0xDF,0x88,0x53,0xBB,0x2D,0x55,0x1B,},
 },
 { .algo = SYM_ARIA, .ivsz = 16, .keysz = 128, .sz = 128, .aadsz = 128,
  .key = {
    0x42,0xB9,0x13,0x36,0xE6,0x7D,0xF0,0x60,0x66,0x42,0x19,0xBF,0xFF,0x9A,0xE6,0x19,},
  .iv = {
    0xE8,0x35,0x57,0x41,0x3F,0x04,0xA9,0x51,0x44,0x9D,0x27,0x33,0xC5,0xE2,0x43,0x66,},
  .pt = {
    0xD9,0xDD,0xE5,0xFE,0xD1,0xEF,0x03,0xED,0x6C,0x2A,0x72,0x82,0x4A,0xFB,0xFC,0x2F,
    0xA3,0x0C,0xB2,0x8F,0x39,0x68,0x83,0xA7,0x8B,0xE1,0x0E,0x6D,0x4C,0xAF,0xB5,0x86,
    0x13,0x59,0xF3,0x54,0x54,0xD9,0xEF,0x30,0x8F,0xFB,0x51,0xF4,0xC7,0x06,0x54,0xBD,
    0x36,0x9E,0x1C,0xEF,0x3F,0xE9,0x4B,0x79,0xA4,0xF1,0xCF,0x5A,0xF9,0x49,0xFD,0x64,
    0x59,0xF4,0xE4,0x3F,0x57,0x82,0xDB,0xB2,0x37,0x7C,0x5D,0x1E,0x5F,0x02,0x17,0x4B,
    0x08,0xB3,0x3E,0x67,0x39,0xCD,0x26,0x4C,0xF6,0x95,0x11,0x02,0xB5,0xFA,0x45,0x85,
    0x11,0x75,0x61,0xC8,0xC2,0x33,0xF0,0xF9,0xCD,0x76,0x3F,0x07,0xF8,0x39,0x6C,0x62,
    0x81,0x13,0xC0,0x02,0x0F,0x5D,0x3E,0xAA,0xE9,0x97,0x7C,0x6E,0x66,0x08,0xB2,0x73,},
  .ct = {
    0x8B,0x11,0x93,0x82,0x16,0x8D,0x18,0x9E,0x82,0x23,0xFD,0xAF,0x52,0x1B,0x92,0x50,
    0x70,0x52,0x67,0x66,0x45,0x94,0x2F,0x4B,0x6E,0x36,0xE1,0x91,0x96,0x47,0xD2,0x8F,
    0xDE,0x77,0xD0,0xD6,0x1F,0x62,0xDE,0xF4,0xE7,0xDE,0x45,0xAB,0xDE,0x99,0xE6,0x4B,
    0x35,0xE8,0x94,0x25,0xD9,0x65,0x39,0x38,0x1D,0x04,0x78,0xB9,0x29,0x84,0x80,0x59,
    0x14,0x50,0x77,0xE1,0x55,0x74,0xF8,0xFF,0x3C,0x83,0x8C,0x55,0xF5,0x97,0xFF,0x37,
    0xB0,0x68,0xDF,0xE8,0xB2,0xCD,0xBF,0x11,0x78,0x40,0x5F,0x76,0xBF,0xFA,0x3F,0xB6,
    0x1D,0xD3,0xE2,0xCC,0xF6,0xDA,0xF3,0xE3,0x37,0xD0,0x3F,0xB8,0x9B,0x2D,0xEA,0x5A,
    0x65,0xCB,0x82,0x6E,0x52,0x74,0x42,0x29,0x9F,0x13,0x08,0xA6,0xD8,0x8B,0x59,0xC0,},
  .aad = {
    0xA5,0xA5,0x11,0xF6,0x7D,0x34,0x56,0x8F,0xB7,0xB1,0x9E,0xB7,0x7B,0xF1,0x7C,0x89,
    0x09,0x85,0x49,0xC5,0xAA,0xE1,0xBB,0x1A,0xE5,0xBE,0xB9,0xA5,0xF5,0xBC,0x6E,0xB5,
    0x7B,0x4C,0x9D,0xD1,0x71,0xCD,0x34,0xFC,0x5F,0xF5,0x23,0x37,0xD1,0x73,0x6E,0x48,
    0x08,0xD2,0x81,0xBA,0xF0,0xA1,0xC5,0x25,0x52,0xD1,0x70,0xAF,0x4B,0x5E,0xA1,0xD3,
    0xFD,0x32,0xAC,0x61,0x84,0x46,0xB2,0xC6,0x2B,0x0A,0x76,0x8E,0xE0,0x07,0x6B,0x27,
    0xE6,0xC2,0x12,0xE8,0xCA,0xE4,0x82,0x51,0x98,0x99,0x48,0x95,0x4E,0x36,0x72,0x55,
    0x91,0x1E,0xE7,0xAF,0x9F,0xE6,0xFA,0x77,0x85,0xB7,0x3E,0xC4,0x92,0xF4,0x9B,0xAF,
    0x0B,0x1D,0xA1,0x57,0x20,0xF4,0x1D,0x29,0x1F,0xDE,0xEA,0x5E,0xE8,0x8B,0x0A,0xC4,},
  .tag = {
    0x8B,0xDE,0xB3,0x59,0x3E,0xCC,0x81,0x25,0x60,0xF3,0x4E,0x83,0x8E,0x40,0x3A,0x1E,},
 },
 { .algo = SYM_ARIA, .ivsz = 16, .keysz = 192, .sz = 128, .aadsz = 128,
  .key = {
    0x50,0xBA,0xBE,0x9A,0x3E,0xD4,0x00,0x66,0x65,0x02,0xCC,0x38,0x8B,0xFF,0xC7,0xB4,
    0x12,0xB8,0xF6,0x57,0xD7,0xA3,0xC9,0x65,},
  .iv = {
    0x59,0x52,0x58,0x23,0x1E,0x48,0xEC,0x47,0x52,0x0B,0xC1,0xAD,0xB2,0x7B,0x0A,0x4B,},
  .pt = {
    0xA8,0x61,0x36,0x67,0xB7,0x4B,0x72,0x07,0x1A,0x98,0x6F,0xAA,0xA8,0xCF,0x65,0x35,
    0xFB,0x35,0x58,0x30,0xD1,0x9E,0x9A,0x32,0xB2,0x83,0x91,0x9A,0xD4,0x55,0xBA,0x80,
    0x3B,0x11,0xEE,0xEC,0x24,0x15,0xE4,0x45,0xA4,0x32,0xF8,0x0C,0x8D,0x02,0x2A,0xCA,
    0x91,0x7B,0x6A,0x46,0xAA,0xC5,0x13,0xFC,0xB9,0x49,0xB5,0xCB,0x6D,0x0B,0x17,0xEE,
    0x66,0x39,0x7C,0x2D,0x9A,0x04,0x26,0x54,0xF8,0xAE,0x19,0xE5,0x4C,0xE4,0x21,0x0A,
    0x63,0x4F,0x16,0xCD,0x6F,0x66,0x5F,0x8B,0xAC,0x86,0xB5,0xA6,0x44,0x44,0x29,0x7B,
    0x71,0x02,0x69,0x94,0xE1,0xC0,0x3F,0x1E,0x5E,0x35,0x5A,0x9D,0xAE,0x1E,0x51,0xDE,
    0xB8,0xD7,0xE5,0x2D,0xE9,0x28,0x87,0xC9,0xD6,0x61,0x1A,0x95,0x23,0xA9,0xF9,0x10,},
  .ct = {
    0x61,0xCF,0x71,0x99,0x1D,0x7B,0xCF,0xBB,0x04,0x46,0x5A,0x6B,0x59,0x26,0xD5,0xD9,
    0xAE,0x1B,0x2E,0x6E,0x7D,0x38,0x34,0xF9,0x53,0x46,0xEA,0x24,0xEA,0xE6,0xF7,0xA5,
    0xCE,0xAF,0xED,0x4B,0x5E,0x80,0x05,0x2B,0xC8,0x87,0x99,0x4D,0x49,0x85,0x31,0x53,
    0xA5,0xDE,0x26,0xE8,0x80,0x9B,0xA2,0x4A,0x51,0x56,0xB6,0x9E,0xDB,0x59,0x14,0xCC,
    0x42,0x7E,0x18,0x90,0x4D,0xB4,0x90,0x62,0x92,0xF5,0x18,0x75,0xC9,0x2B,0xF1,0x2C,
    0x6C,0x32,0x2D,0x6F,0x23,0xAE,0xF4,0xA3,0x5C,0xD7,0x2B,0xCE,0x4D,0x21,0xC0,0x75,
    0xA2,0x59,0xF4,0x6D,0xA9,0xC4,0x24,0x6A,0xEA,0x44,0x8B,0xF8,0xC2,0x7F,0x1B,0xE7,
    0x22,0xC2,0x33,0xA5,0x0E,0x9E,0x00,0xF1,0xF0,0xA1,0x5B,0x19,0x46,0x5E,0x19,0xA7,},
  .aad = {
    0xA3,0x93,0x3C,0x87,0xC0,0xF2,0x37,0x8A,0x1E,0xEF,0x44,0x9C,0x7B,0x58,0xC3,0x2E,
    0xDA,0x3B,0x5E,0xCF,0xE0,0xB4,0x92,0x9D,0x7E,0x03,0x6A,0xFF,0xD0,0xE1,0x8E,0x96,
    0x45,0x15,0x7D,0x70,0x01,0x42,0x17,0x7F,0x7F,0x03,0x5E,0x4A,0x7B,0x39,0x7D,0xE3,
    0x0F,0xA4,0x0A,0x19,0x1C,0xB1,0x88,0xEE,0xEB,0x93,0x30,0x4C,0x14,0x95,0xF1,0xF3,
    0x9F,0xAF,0xB5,0xB6,0x6A,0x57,0xE6,0xE7,0xCA,0x99,0x30,0x10,0x75,0x6A,0x89,0xE3,
    0xA0,0x3A,0x6F,0x74,0x64,0xC8,0x71,0xA6,0x66,0x3A,0xF1,0xE3,0xB7,0x6D,0x28,0x11,
    0xF9,0x8A,0x6B,0xC1,0xC4,0xDA,0xAC,0xA9,0x48,0xDB,0x43,0x54,0x33,0x93,0xEF,0x18,
    0xD5,0x24,0x17,0x49,0x81,0xA1,0x56,0xAC,0x37,0x20,0x37,0x2E,0x81,0x10,0x3D,0xD6,},
  .tag = {
    0xFA,0xD1,0x00,0x3D,0x3F,0xFB,0x3A,0x0D,0xCA,0xFC,0xAF,0x60,0xF0,0xF4,0x30,0x0F,},
 },
 { .algo = SYM_ARIA, .ivsz = 16, .keysz = 256, .sz = 128, .aadsz = 128,
  .key = {
    0x1C,0x81,0x7A,0x89,0x1E,0x07,0x80,0xE9,0xE1,0x4B,0x4C,0x02,0x62,0xA8,0xD8,0xB4,
    0x8E,0xA4,0xA2,0x52,0xF9,0xD3,0x03,0xA7,0xD2,0xF9,0xBC,0x3B,0x17,0x6F,0xD2,0xD2,},
  .iv = {
    0x05,0xC8,0x9D,0x36,0xD3,0xB3,0x1B,0x36,0x9F,0x23,0x8A,0xEF,0xA9,0xAE,0x35,0x4A,},
  .pt = {
    0xBF,0x33,0x8E,0xC6,0xF8,0xC0,0x7D,0x78,0xA5,0xB3,0xF8,0x50,0x85,0x1F,0xD4,0x9D,
    0x38,0x71,0xDA,0xD3,0xF6,0x53,0x1E,0x8C,0x81,0xD0,0x8C,0xCE,0x58,0xB9,0xC4,0x8C,
    0x2E,0x48,0x28,0x6F,0x9A,0x04,0x32,0xD6,0x10,0xE4,0x0C,0x1B,0x10,0xB7,0x5A,0x18,
    0x9D,0xC3,0x5A,0xE9,0xF1,0xAD,0x30,0xF4,0x6F,0x99,0x7B,0x27,0xD9,0x91,0x2C,0x81,
    0xC3,0x2B,0x98,0xD4,0x48,0x66,0xCC,0xC9,0xFB,0xD6,0x20,0x24,0x20,0x01,0x0F,0x49,
    0x1D,0x08,0x45,0xFF,0x2B,0x8A,0xFA,0x75,0x51,0xC5,0x7F,0x83,0x93,0xFE,0x16,0x31,
    0x67,0x23,0x07,0x7D,0x68,0xB0,0xF0,0x59,0x4E,0xCF,0x5D,0xF4,0x1E,0xC3,0x98,0x3A,
    0x9E,0x86,0xC3,0x9E,0x0C,0xB1,0x23,0x17,0x0F,0x9D,0xBF,0x68,0xEE,0xC8,0x2A,0xA5,},
  .ct = {
    0xB9,0x36,0xF1,0x31,0x14,0x07,0x6F,0x04,0x92,0x3B,0x62,0x9E,0xF4,0x3B,0x9C,0x6A,
    0x74,0x33,0x58,0x1A,0x61,0x88,0xE4,0x40,0xFF,0xEF,0xA0,0x47,0x9B,0x85,0x0A,0x65,
    0xAF,0xF6,0x21,0xB5,0x33,0xFB,0x64,0x2F,0xED,0x3F,0xE4,0x01,0xD5,0x43,0xD4,0x95,
    0xAE,0x55,0x73,0x0C,0x22,0x23,0x06,0xB7,0x63,0x92,0xD3,0x0D,0xE6,0x28,0xF6,0xDC,
    0x3D,0x20,0x5E,0xB2,0xF2,0xD7,0x59,0x8E,0x32,0xD5,0x60,0x3E,0x0B,0x66,0x36,0x3D,
    0xC1,0x40,0x12,0x06,0x90,0x3B,0xE5,0x6B,0xD6,0x52,0x3B,0xF2,0xB5,0x97,0xE2,0xD6,
    0xB5,0xDD,0x8F,0xD9,0x65,0xA7,0x35,0x98,0xFA,0x5C,0xC6,0x07,0xEF,0x05,0xB0,0x16,
    0xB9,0x1A,0x63,0x42,0x1D,0x4A,0xD8,0x7D,0x51,0x95,0x75,0x6E,0xD2,0x51,0xA6,0x9A,},
  .aad = {
    0x00,0x7A,0x9D,0xF3,0x64,0xA8,0x48,0x8F,0xF1,0x18,0xEA,0x12,0x70,0xC6,0xA0,0xF3,
    0x09,0x87,0xFA,0x4D,0xFC,0xEC,0x54,0xE2,0x92,0x69,0x64,0x61,0x52,0xB6,0x0F,0xE4,
    0x77,0x76,0x81,0xBD,0xA2,0x17,0x7C,0x72,0xCD,0xF9,0xF0,0x06,0x80,0xD2,0xCD,0x7A,
    0x47,0x51,0x15,0x94,0x63,0x01,0x35,0xDF,0xC0,0x71,0x95,0xF3,0x27,0x92,0x6E,0xF6,
    0xB5,0x60,0xDC,0x63,0x8C,0xC4,0x34,0x0A,0xC8,0xB9,0x97,0x59,0xB5,0xAF,0xC7,0xD9,
    0x3F,0x2C,0x3A,0xFB,0xA9,0xB9,0x6D,0x15,0x82,0xFC,0x7B,0xA8,0xD5,0x22,0xEE,0xE4,
    0xA1,0x80,0xD5,0x6E,0x88,0x79,0x17,0x60,0xCB,0xA2,0x06,0x92,0x76,0x24,0x37,0x18,
    0xD8,0x62,0x92,0x0B,0x36,0xDC,0xA5,0x8D,0xC1,0x53,0x3D,0x07,0xC4,0x2F,0x38,0xB5,},
  .tag = {
    0xCD,0x2A,0xBC,0x6F,0xB2,0xDF,0x2D,0xC3,0x76,0xB8,0x6F,0x84,0xDD,0x1F,0x25,0x10,},
 },
 { .algo = SYM_LEA, .ivsz = 12, .keysz = 128, .sz = 16, .aadsz = 16,
  .key = {
    0x1D,0xE6,0x90,0xF6,0x46,0xBD,0x51,0x1C,0xD7,0x40,0x6D,0x1A,0x27,0xB2,0x29,0xF2,},
  .iv = {
    0xBD,0xD8,0x44,0x35,0x78,0x5E,0xCF,0x80,0x0D,0x76,0x3F,0x47,},
  .pt = {
    0xB7,0xC2,0xC1,0xD1,0x29,0x74,0xCD,0x84,0xC8,0xB4,0xFE,0x63,0x17,0x42,0x21,0xD5,},
  .ct = {
    0x27,0xED,0x4F,0x94,0x34,0xF6,0x08,0xED,0x7B,0x36,0x4D,0xB0,0xDB,0x75,0xB8,0x11,},
  .aad = {
    0x72,0x5C,0x8C,0xA8,0x00,0xE2,0xB1,0x55,0xE3,0xB8,0xF2,0x86,0xB1,0x6C,0xB7,0xD5,},
  .tag = {
    0x58,0x40,0x14,0xB9,0x71,0x13,0x0B,0xD0,0x8B,0x0F,0xC7,0xD3,0x76,0x70,0x59,0x6B,},
 },
 { .algo = SYM_LEA, .ivsz = 12, .keysz = 192, .sz = 16, .aadsz = 16,
  .key = {
    0xF9,0x0E,0x43,0x31,0xF3,0x7E,0x19,0x82,0xCE,0xC3,0x04,0xD3,0xE6,0x9C,0x59,0x75,
    0x56,0x86,0x30,0x74,0x0D,0x81,0x16,0x78,},
  .iv = {
    0x25,0x17,0x02,0xE9,0x70,0x9B,0x8B,0x56,0x53,0xAF,0x57,0x18,},
  .pt = {
    0xD7,0x08,0xD7,0x32,0xFD,0x76,0x31,0x7C,0x52,0x1E,0x7E,0x01,0xC4,0x0A,0x36,0xA5,},
  .ct = {
    0x7E,0xAA,0x9D,0x54,0x84,0x94,0x62,0xE8,0x3C,0x48,0xFF,0xC8,0x7D,0x7C,0x33,0xBA,},
  .aad = {
    0xB4,0xE5,0xE8,0x0B,0x4C,0xFF,0x2F,0xB5,0x13,0x98,0xE1,0x6D,0xBE,0x5A,0x89,0xE4,},
  .tag = {
    0xF4,0x43,0x02,0x96,0xDF,0xC7,0xF6,0xA3,0x22,0x9C,0x4C,0x6D,0xB5,0x3C,0xA1,0x8C,},
 },
 { .algo = SYM_LEA, .ivsz = 12, .keysz = 256, .sz = 16, .aadsz = 16,
  .key = {
    0x11,0xE0,0x1D,0xD3,0x1D,0xEE,0x9B,0xA3,0x12,0x23,0x02,0xA1,0xC1,0x5A,0xCE,0x29,
    0xA6,0x72,0x76,0xA3,0x1B,0xAB,0x45,0x06,0xCA,0x53,0x65,0x9B,0x68,0xA3,0x3D,0x04,},
  .iv = {
    0xA1,0xE4,0xFD,0x7C,0x4E,0xD5,0x76,0x60,0xEE,0x51,0x30,0xEF,},
  .pt = {
    0x54,0x2D,0xB6,0x4E,0x9D,0x60,0x35,0xCE,0x65,0x66,0x45,0x72,0x3B,0xE6,0x07,0xAC,},
  .ct = {
    0x3A,0x84,0xAF,0xF1,0x61,0x25,0x49,0x24,0x64,0x66,0x1D,0xD1,0x47,0x59,0xC9,0x3E,},
  .aad = {
    0x51,0x92,0x70,0x68,0x78,0x4E,0xE4,0x4B,0x4C,0x95,0x07,0x3D,0xAC,0x19,0xD0,0x25,},
  .tag = {
    0xC6,0xF6,0xBC,0x86,0xA8,0xE4,0xFA,0x55,0xC9,0xA2,0x57,0xF5,0xFC,0xD9,0xC7,0x06,},
 },
 { .algo = SYM_SM4, .ivsz = 12, .keysz = 128, .sz = 64, .aadsz = 20,
  .key = {
    0x01,0x23,0x45,0x67,0x89,0xAB,0xCD,0xEF,0xFE,0xDC,0xBA,0x98,0x76,0x54,0x32,0x10,},
  .iv = {
    0x00,0x00,0x12,0x34,0x56,0x78,0x00,0x00,0x00,0x00,0xAB,0xCD,},
  .pt = {
    0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,0xBB,
    0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,
    0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
    0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xEE,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,0xAA,},
  .ct = {
    0x17,0xF3,0x99,0xF0,0x8C,0x67,0xD5,0xEE,0x19,0xD0,0xDC,0x99,0x69,0xC4,0xBB,0x7D,
    0x5F,0xD4,0x6F,0xD3,0x75,0x64,0x89,0x06,0x91,0x57,0xB2,0x82,0xBB,0x20,0x07,0x35,
    0xD8,0x27,0x10,0xCA,0x5C,0x22,0xF0,0xCC,0xFA,0x7C,0xBF,0x93,0xD4,0x96,0xAC,0x15,
    0xA5,0x68,0x34,0xCB,0xCF,0x98,0xC3,0x97,0xB4,0x02,0x4A,0x26,0x91,0x23,0x3B,0x8D,},
  .aad = {
    0xFE,0xED,0xFA,0xCE,0xDE,0xAD,0xBE,0xEF,0xFE,0xED,0xFA,0xCE,0xDE,0xAD,0xBE,0xEF,
    0xAB,0xAD,0xDA,0xD2},
  .tag = {
    0x83,0xDE,0x35,0x41,0xE4,0xC2,0xB5,0x81,0x77,0xE0,0x65,0xA9,0xBF,0x7B,0x62,0xEC,},
 },
 {.algo = CRYPTO_ALGO_INITIALIZED, .keysz = 0, .sz = 0 },
};

void gcm_kat(operation_mode_t opmode)
{
    CRYPTO_STATUS ret = CRYPTO_ERROR;
    struct gcm_test_vector_t *vector;
    ctx_handle_t handle = {0,};
    int rdonly = 0;
    uint8_t tag[16];       // 16B
    uint8_t buf[128];       // 16B
    uint32_t sz;
    int i;
    int last;
    int keybyte;

    handle[0] = 12;
    last = sizeof(gcm_kat_vector) / sizeof(gcm_kat_vector[0]);

    for (i=0; i < last; ++i) {
        vector = &gcm_kat_vector[i];
        if (vector->algo == CRYPTO_ALGO_INITIALIZED && vector->keysz == 0) {
            break;
        }

        if (((opmode == OP_MODE_APPROVED_KCMVP) || (opmode == OP_MODE_APPROVED_OSCCA)) &&
            (vector->algo & SYM_MASK) == SYM_AES) {
            continue;
        } else if ((opmode != OP_MODE_APPROVED_KCMVP) &&
            ((vector->algo & SYM_MASK) == SYM_ARIA || (vector->algo & SYM_MASK) == SYM_LEA)) {
            continue;
        } else if ((opmode != OP_MODE_APPROVED_OSCCA) &&
            (vector->algo & SYM_MASK) == SYM_SM4) {
            continue;
        }

        memset(buf, 0, sizeof(buf));
        memset(tag, 0, sizeof(tag));
        ret = axiocrypto_allocate_slot(handle, vector->algo, 0);
        sp_assert_equal(ret, CRYPTO_SUCCESS);

        keybyte = vector->keysz >> 3;
        ret = axiocrypto_sym_putkey(handle, vector->key, keybyte, axiocrypto_crc(vector->key, keybyte), rdonly);
        sp_assert_equal(ret, CRYPTO_SUCCESS);

        sz = vector->sz;
        ret = axiocrypto_sym_enc_GCM(handle, vector->algo, vector->pt, vector->sz, vector->aad, vector->aadsz, tag, sizeof(tag), vector->iv, vector->ivsz, buf, &sz);
        sp_assert_equal(ret, CRYPTO_SUCCESS);
        sp_assert_equal(memcmp(vector->tag, tag, 16), 0);

        printf("KAT %s-GCM-%d ENC pass\n", algorithm_string(vector->algo), vector->keysz);

        memset(buf, 0, sizeof(buf));
        memset(tag, 0, sizeof(tag));
        sz = vector->sz;
        ret = axiocrypto_sym_dec_GCM(handle, vector->algo, vector->ct, vector->sz, vector->aad, vector->aadsz, vector->tag, sizeof(vector->tag), vector->iv, vector->ivsz, buf, &sz);
        sp_assert_equal(ret, CRYPTO_GCM_ACCEPT);
        sp_assert_equal(memcmp(vector->pt, buf, vector->sz), 0);

        ret = axiocrypto_free_slot(handle, SYM_ARIA);
        sp_assert_equal(ret, CRYPTO_SUCCESS);

        printf("KAT %s-GCM-%d DEC pass\n", algorithm_string(vector->algo), vector->keysz);
    }
    printf("\n");
}

#if 0
void sym_kat(void)
{
    CRYPTO_STATUS ret;
    ctx_handle_t handle = {0,};
    int rdonly = 0;
    uint8_t *key;       // 16B
    uint8_t iv[16];     // 16B
    uint8_t *pt;        // 128B
    uint8_t *ct;
    uint8_t *tag;       // 16B
    uint8_t *aad;       // 128B
    uint8_t dst[128];
    uint8_t _tag[128];
    uint32_t o;
#ifndef AXIOCRYPTO_CERT_FIPS
    printf("FIPS mode, %s() just return\n", __func__);
    return;
#endif

    key = ariaGcmKey;
    pt  = ariaGcmPT;
    ct  = ariaGcmC;
    aad = ariaGcmAdata;
    tag = ariaGcmT;

    ret = axiocrypto_random(handle, sizeof(ctx_handle_t));
    sp_assert_equal(ret, 0);

    ret = axiocrypto_allocate_slot(handle, SYM_ARIA, 0);
    sp_assert_equal(ret, 0);

    ret = axiocrypto_sym_putkey(handle, key, 16, axiocrypto_crc(key, 16), rdonly);
    sp_assert_equal(ret, 0);

    memcpy(iv, ariaGcmIV, 16);;
    o = 128;
    ret = axiocrypto_sym_enc_GCM(handle, SYM_ARIA, pt, 128, aad, 128, _tag, 16, iv, 16, dst, &o);
    sp_assert_equal(ret, 0);

    sp_assert_equal(o, 128);
    sp_assert_equal(memcmp(ct, dst, 128), 0);
    sp_assert_equal(memcmp(tag, _tag, 16), 0);

    printf("KAT ARIA GCM ENC pass\n");

    memcpy(iv, ariaGcmIV, 16);;
    o = 128;
    ret = axiocrypto_sym_dec_GCM(handle, SYM_ARIA, ct, 128, aad, 128, _tag, 16, iv, 16, dst, &o);
    sp_assert_equal(ret, CRYPTO_GCM_ACCEPT);

    sp_assert_equal(o, 128);
    sp_assert_equal(memcmp(pt, dst, 128), 0);

    ret = axiocrypto_free_slot(handle, SYM_AES);
    sp_assert_equal(ret, 0);

    printf("KAT ARIA GCM DEC pass\n");
}
#endif

uint8_t ecdh256rB[] ={
        0x39,0x91,0x57,0x1E,0xF3,0x6C,0xD2,0xA0,0x56,0x8C,0xB6,0x77,0x90,0x23,0xC4,0xF9,
        0xB7,0x8E,0x2A,0x97,0xF6,0x78,0x97,0x48,0x0F,0x8E,0xA4,0xB8,0x65,0x69,0x5A,0xAF };
const uint8_t ecdh256KTA1x1[] ={
        0x45,0x99,0xFB,0xE5,0xF0,0xEF,0x99,0xF1,0x31,0x5C,0x83,0xDC,0x46,0x13,0xFE,0x32,
        0x6A,0xC7,0x11,0xF8,0x46,0xAD,0xB7,0xF7,0x4D,0xA0,0x5D,0xA3,0x3F,0xCD,0x8E,0x56 };
const uint8_t ecdh256KTA1y1[] = {
        0xCC,0xAD,0x62,0x4D,0x5F,0x9C,0x07,0x36,0x28,0xCE,0x22,0x84,0xD7,0x65,0x5E,0x06,
        0x4E,0xB2,0x19,0xA5,0xD5,0x6E,0x06,0x60,0x84,0x28,0xD6,0xEA,0x58,0x39,0x3F,0x77 };
const uint8_t ecdh256KABx1[] = {
        0x26,0xF8,0x12,0x74,0xCC,0x42,0xA5,0x41,0x3A,0xED,0x2A,0xC9,0x5E,0x2D,0x85,0x05,
        0x9B,0xCB,0x75,0x80,0xF2,0x60,0xB1,0x8D,0xDF,0x8C,0xD7,0x01,0x78,0x17,0x72,0x14 };
const uint8_t ecdh256KABy1[] = {
        0x7F,0xBA,0x1B,0x85,0x48,0xB7,0x9F,0x57,0x1C,0x88,0xD9,0x4B,0x52,0xD9,0x8F,0x5E,
        0xFA,0xA0,0xFE,0x83,0xF0,0x09,0xD7,0x9A,0x48,0x9A,0xE8,0xA0,0x1F,0x97,0x43,0xF0 };

void ecdh_kat(void)
{
    CRYPTO_STATUS ret;
    ctx_handle_t handle = {0,};
    ctx_handle_t symhandle2 = {0,};
    int rdonly = 0;
    uint8_t KTA[64];
    uint8_t KAB[64];
    char msg[] = "1234567890123456";
    uint8_t ct[16];
    uint8_t iv[16];
    uint32_t sz;
    ALGORITHM algo = SYM_ARIA;
    operation_mode_t opmode = OP_MODE_NOTHING;

    ret = axiocrypto_info(NULL, 0, &opmode);
    if (opmode == OP_MODE_APPROVED_FIPS1402) {
        algo = SYM_AES;
    }

    handle[0] = 2;
    handle[1] = 23;
    ret = axiocrypto_allocate_slot(handle, ASYM_ECDH_P256, 0);
    if (ret == CRYPTO_ERR_NOT_ALLOWED_IN_APPROVED_MODE) {
        return;
    }
    sp_assert_equal(ret, 0);

    ret = axiocrypto_asym_putkey(handle, ASYM_ECDH_P256, ecdh256rB, 32, axiocrypto_crc(ecdh256rB, 32), NULL, 0, 0, rdonly);
    sp_assert_equal(ret, 0);
    ret = axiocrypto_asym_getkey(handle, ASYM_ECDH_P256, KTA, 64);
    sp_assert_equal(ret, 0);
    memset(KTA, 0, 64);

    memcpy(KTA, ecdh256KTA1x1, 32);
    memcpy(&KTA[32], ecdh256KTA1y1, 32);
    ret = axiocrypto_ecdh_computekey(handle, KTA, 64, KAB, 64);
    sp_assert_equal(ret, 0);
    sp_assert_equal(memcmp(KAB, ecdh256KABx1, 32), 0);
    sp_assert_equal(memcmp(&KAB[32], ecdh256KABy1, 32), 0);

    symhandle2[0] = 3;

    ret = axiocrypto_allocate_slot(symhandle2, algo, 0);
    sp_assert_equal(ret, 0);
    // put key to sym slot 1
    ret = axiocrypto_sym_putkey(symhandle2, KAB, 16, axiocrypto_crc(KAB, 16), 0);
    sp_assert_equal(ret, 0);

    memset(iv, 0, 16);
    sz = 16;
    ret = axiocrypto_sym_enc_init(symhandle2, algo, SYM_MODE_CBC, iv, 16);
    sp_assert_equal(ret, 0);
    ret = axiocrypto_sym_enc_update(symhandle2, (uint8_t *)msg, 16, ct, &sz);
    sp_assert_equal(ret, 0);
    sp_assert_equal(sz, 16);
    ret = axiocrypto_sym_enc_final(symhandle2, NULL, 0);

    ret = axiocrypto_free_slot(handle, ASYM_ECDSA_P256);
    sp_assert_equal(ret, 0);

    ret = axiocrypto_free_slot(symhandle2, algo);
    sp_assert_equal(ret, 0);

    printf("KAT ECDH pass\n");
}

const uint8_t ecdsa_p256_qx5[] = {0x70,0xFA,0x28,0xF8,0x34,0x65,0x01,0xEB,0x68,0x30,0x25,0x07,0xB0,0xD9,0xA4,0xB1,0x47,0x2C,0x99,0x66,0xEE,0x92,0xB6,0x0F,0x47,0xEE,0x25,0x9A,0xB5,0x02,0xFC,0xBC};
const uint8_t ecdsa_p256_qy5[] = {0x1C,0x99,0x2B,0x0D,0x81,0x5A,0x5E,0x08,0x2E,0x29,0x53,0xDB,0x59,0xD8,0xD3,0x41,0xDC,0x43,0xE1,0xCF,0x28,0xEC,0x68,0x54,0x46,0xB4,0x19,0x60,0x17,0x47,0xDB,0x63};
const uint8_t ecdsa_p256_sig_r5[] = {0xCB,0x83,0xD5,0x17,0xEB,0x96,0x85,0x10,0x8F,0xB4,0x92,0x2F,0x0F,0x42,0x62,0xD9,0x1D,0x08,0xFF,0x1A,0x78,0xC7,0xBD,0x29,0xC7,0x67,0x52,0xF4,0xAC,0x79,0x63,0x13};
const uint8_t ecsda_p256_sig_s5[] = {0x7B,0xED,0xA2,0x69,0xCC,0xED,0x32,0xB7,0xB2,0xD2,0x94,0x1F,0xFE,0x64,0xB9,0x07,0x60,0xA2,0x03,0xB6,0xDA,0xE1,0x1B,0xBB,0x4D,0x7C,0x13,0x24,0x08,0x3A,0xD6,0x43};
const uint8_t ecdsa_p256_m5[] = {
        0x34,0x8B,0x91,0x7B,0xE7,0x43,0x81,0xBD,0xE2,0x3E,0x3E,0x1F,0x04,0xB6,0x19,0x28,
        0xDB,0x1B,0xED,0x55,0x3E,0x74,0x8D,0xF8,0x62,0x31,0xEC,0xD8,0x85,0x58,0x48,0xD7,
        0xA9,0x63,0x21,0x31,0x78,0xCB,0x3C,0x84,0xC0,0x9A,0x89,0x4D,0xAC,0xF9,0x26,0xF9,
        0x27,0x10,0x4D,0x34,0x88,0x33,0x78,0xAE,0xFE,0xBB,0x7B,0xDB,0xCB,0x6B,0xE4,0x02,
        0xD8,0xDE,0x61,0x1B,0xA7,0xCF,0x80,0xBE,0x29,0xB4,0x83,0xC3,0x87,0x89,0x97,0xB7,
        0x5A,0x3C,0x39,0xD3,0x6D,0x9A,0x0A,0x99,0x78,0x28,0xE2,0xCA,0xF6,0xD7,0x5F,0xC8,
        0x86,0xE9,0xC2,0x21,0xF7,0x07,0x63,0x63,0x6D,0xDB,0x77,0xDB,0xC1,0x21,0x7D,0x70,
        0x8F,0x94,0x16,0x3E,0x03,0xA4,0x8E,0x1A,0xF4,0x50,0xE1,0xA5,0x45,0x1B,0x7E,0x1A
};

const uint8_t ECDSAP256Kpg_x1[] = {0x84,0xC1,0xAB,0x5E,0x9F,0x5A,0x2A,0x77,0x00,0xA0,0x64,0xE7,0x78,0xF4,0xCC,0x78,0xDB,0x6D,0x95,0xF6,0xCF,0x6E,0xEE,0xF3,0x4C,0xD9,0x71,0x72,0xDE,0x5B,0x02,0x10};
const uint8_t ECDSAP256Kpg_Yx1[] = {0xE4,0xC4,0xE6,0x57,0x35,0x7F,0x6F,0xC4,0x2B,0xFF,0x0A,0xDD,0x6F,0x9D,0x25,0x1B,0x10,0x23,0x7C,0x89,0xB8,0x87,0x53,0xA1,0xB4,0x40,0x3D,0x31,0x59,0x9C,0xDB,0xBB};
const uint8_t ECDSAP256Kpg_Yy1[] = {0xDC,0x56,0xA6,0xB7,0x10,0xE5,0x28,0x5E,0x44,0x25,0x9C,0xCC,0xEA,0x8F,0x84,0x34,0x05,0x32,0xFD,0x36,0x36,0xE2,0x6F,0xE4,0x83,0x20,0x40,0xED,0x2A,0x9F,0x43,0xCE};
void ecdsa_kat(void)
{
    CRYPTO_STATUS ret;
    uint8_t Q[64];
    uint8_t sig[64];
    uint8_t msg[] = {0,1,2,3,4,5,6,7,8,10};
    ctx_handle_t handle0 = {0,};
    ctx_handle_t handle1 = {0,};
    ctx_handle_t handle2 = {0,};
    int rdonly = 0;
    uint32_t sz;

    handle0[0] = 1;
    handle1[0] = 2;
    handle2[0] = 3;
    ret = axiocrypto_allocate_slot(handle0, ASYM_ECDSA_P256, 0);
    sp_assert_equal(ret, 0);

    ret = axiocrypto_allocate_slot(handle1, ASYM_ECDSA_P256, 0);
    sp_assert_equal(ret, 0);

    ret = axiocrypto_allocate_slot(handle2, ASYM_ECDSA_P256, 0);
    sp_assert_equal(ret, 0);

    ret = axiocrypto_asym_putkey(handle1, ASYM_ECDSA_P256,
                                ECDSAP256Kpg_x1, 32, axiocrypto_crc(ECDSAP256Kpg_x1, 32), NULL, 0, 0, 0);
    sp_assert_equal(ret, 0);

    ret = axiocrypto_asym_getkey(handle1, ASYM_ECDSA_P256, Q, 64);
    sp_assert_equal(ret, 0);
    sp_assert_equal(memcmp(Q, ECDSAP256Kpg_Yx1, 32), 0);
    sp_assert_equal(memcmp(&Q[32], ECDSAP256Kpg_Yy1, 32), 0);

    memcpy(Q, ecdsa_p256_qx5, 32);
    memcpy(&Q[32], ecdsa_p256_qy5, 32);
    ret = axiocrypto_asym_putkey(handle0, ASYM_ECDSA_P256, NULL, 0, 0, Q, 64, axiocrypto_crc(Q, 64), rdonly);
    sp_assert_equal(ret, 0);

    memcpy(sig, ecdsa_p256_sig_r5, 32);
    memcpy(&sig[32], ecsda_p256_sig_s5, 32);
    ret = axiocrypto_asym_verify(handle0, ecdsa_p256_m5, sizeof(ecdsa_p256_m5), RAW_MSG, sig, 64);
    sp_assert_equal(ret, CRYPTO_SIG_ACCEPT);

    ret = axiocrypto_asym_genkey(handle2, ASYM_ECDSA_P256, 0);
    sp_assert_equal(ret, 0);

    sz = 64;
    ret = axiocrypto_asym_sign(handle2, msg, sizeof(msg), RAW_MSG, sig, &sz);
    sp_assert_equal(ret, 0);
    sp_assert_equal(sz, 64);

    ret = axiocrypto_asym_verify(handle2, msg, sizeof(msg), RAW_MSG, sig, 64);
    sp_assert_equal(ret, CRYPTO_SIG_ACCEPT);

    ret = axiocrypto_asym_getkey(handle2, ASYM_ECDSA_P256, Q, 64);
    sp_assert_equal(ret, 0);

    ret = axiocrypto_free_slot(handle0, ASYM_ECDSA_P256);
    sp_assert_equal(ret, 0);

    ret = axiocrypto_free_slot(handle1, ASYM_ECDSA_P256);
    sp_assert_equal(ret, 0);

    ret = axiocrypto_free_slot(handle2, ASYM_ECDSA_P256);
    sp_assert_equal(ret, 0);

    printf("KAT ECDSA pass\n");
}

void drbg_test(void)
{
    CRYPTO_STATUS ret;
    uint8_t buf[2][64];
    int i;

    for (i=0; i<2; ++i) {
        memset(buf[i], 0, 64);
        ret = axiocrypto_random(buf[i], 32);
        sp_assert_equal(ret, 0);
        sp_assert_equal(buf[i][32], 0);
        sp_assert_not_equal(buf[i][31], 0);
    }

    sp_assert_not_equal(memcmp(buf[0], buf[1], 32), 0);

    printf("DRBG TEST pass\n");
}

int kat(void)
{
    CRYPTO_STATUS ret = CRYPTO_ERROR;
    operation_mode_t opmode;
    char versionstr[32] = {0,};

	ret = axiocrypto_init(NULL, 0);
    sp_assert_equal(ret, CRYPTO_SUCCESS);

    ret = axiocrypto_info(versionstr, sizeof(versionstr), &opmode);
    sp_assert_equal(ret, CRYPTO_SUCCESS);
    printf("\n%s %s KAT(Known Answer Test) \n\n", operation_mode_string(opmode), versionstr);

    hash_kat(opmode);
    hmac_sha256_kat();

    ecb_kat(opmode);
    cbc_kat(opmode);
    ctr_kat(opmode);
    gcm_kat(opmode);

    ecdh_kat();
    ecdsa_kat();
    drbg_test();
    return 0;
}
